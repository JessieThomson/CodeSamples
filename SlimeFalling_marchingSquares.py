import pygame, sys, time, randomfrom pygame.locals import *import numpy as npimport mathimport joblib  # import Parallel, delayedimport multiprocessingclass Particle:    """    @summary: Data class to store particle details i.e. Position, Direction and speed of movement, radius, etc    """    def __init__(self):        self.__version = 0        """@type: int"""        self.__position = []        self.__movement = []        self.__radius = 0        self.__lifetime = 20    # Python overrides -------------------------------------------------------------------------------------------------    def __str__(self):        printStr = ''        printStr += 'Position: (' + str(self.__position[0]) + ',' + str(self.__position[1]) + ') '        printStr += 'Direction and Speed: (' + str(self.__movement[0]) + ',' + str(self.__movement[1]) + ') '        printStr += 'Radius: ' + str(self.__radius)        return printStr    def __setitem__(self, position, movement, rad, c):        print position, movement, rad        # TODO: Check inputs        self.__position = position        self.__movement = movement        self.__radius = rad    # Properties -------------------------------------------------------------------------------------------------------    @property    def Position(self):        return self.__position    @property    def Movement(self):        return self.__movement    @property    def Radius(self):        return self.__radius    # Methods ----------------------------------------------------------------------------------------------------------    def SetPosition(self, pos):        self.__position = pos    def SetMovement(self, move):        self.__movement = move    def SetRadius(self, rad):        self.__radius = rad    def DecreaseLifetime(self):        self.__lifetime -= 0.1        return True if self.__lifetime <= 0 else Falsedef CalculateGrid(screenWidth, screenHeight, resolution):    x_size = resolution + divmod(screenWidth, resolution)[1]    y_size = resolution + divmod(screenHeight, resolution)[1]    print x_size, y_size    grid = []    for y in range(0, y_size):        temp_list = []        for x in range(0, x_size):            temp_list += [[x * (screenWidth / x_size), y * (screenHeight / y_size)]]        grid += [temp_list]    print np.array(grid).shape    return grid# Takes a binary string of all the four corners of the cell, where 1 = occupied and 0 = empty.#   The corners ('0000') read from left to right: top-left, top-right, bottom-right, bottom-left# Returns a list with pairs of x,y co-ordinates for the start and end of the line(s)#  A----B      0----1      0--P--1#  |    |      |    |      |     |#  |    |  or  |    |  to  S     Q#  C----D      3----2      |     |#                          3--R--2def DrawLine(score, x, y, sizex, sizey, sum_corners):    top_centre = [x + int(sizex/2), y]    left_centre = [x, int(y + sizey/2)]    bottom_centre = [x + int(sizex/2), y + sizey]    right_centre = [x + sizex, y + int(sizey/2)]    if int(score, 2) == 0 or int(score) == 15:        return []    P = []    Q = []    R = []    S = []    # print sum_corners    # Interpolated points:    if sum_corners[0] == sum_corners[1]:        P = [top_centre]    else:        P = [x + ((x + sizex) - x) * ((1 - sum_corners[0]) / (sum_corners[1] - sum_corners[0])), y]    if sum_corners[1] == sum_corners[2]:        Q = [right_centre]    else:        Q = [x + sizex, y + ((y + sizey) - y) * ((1 - sum_corners[1]) / (sum_corners[2] - sum_corners[1]))]    if sum_corners[2] == sum_corners[3]:        R = [bottom_centre]    else:        R = [x + ((x + sizex) - x) * ((1 - sum_corners[3]) / (sum_corners[2] - sum_corners[3])), y + sizey]    if sum_corners[0] == sum_corners[3]:        S = [left_centre]    else:        S = [x, y + ((y + sizey) - y) * ((1 - sum_corners[0]) / (sum_corners[3] - sum_corners[0]))]    if int(score, 2) == 1 or int(score, 2) == 14:        return [S, R]    elif int(score, 2) == 2 or int(score, 2) == 13:        return [R, Q]    elif int(score, 2) == 3 or int(score, 2) == 12:        return [S, Q]    elif int(score, 2) == 4 or int(score, 2) == 11:        return [P, Q]    elif int(score, 2) == 5 or int(score, 2) == 10:        return [S, P, R, Q]    elif int(score, 2) == 6 or int(score, 2) == 9:        return [P, R]    elif int(score, 2) == 7 or int(score, 2) == 8:        return [S, P]def ComputeSquares(index, grid, circle_objs, x_size, cell_size_x, cell_size_y):    score = ''    sum_corner = [0.0, 0.0, 0.0, 0.0]    x = grid[int(math.floor(index / x_size))][index - ((index / x_size) * x_size)][0]    y = grid[int(math.floor(index / x_size))][index - ((index / x_size) * x_size)][1]    # Put 'slime' at bottom of the screen    if int(math.floor(index / x_size))-1 == len(grid[:]) - 2:        sum_corner[2] += 1.1        sum_corner[3] += 1.1    # Put line near top to look like water surface    if int(math.floor(index / x_size))-1 == 10:        sum_corner[2] += 1.1        sum_corner[3] += 1.1    # print x, y    for p in circle_objs:        if abs(p.Position[0] - x) < p.Radius ** 2 and abs(p.Position[1] - y) < p.Radius ** 2:            sum_corner[0] += pow(p.Radius, 2) / (pow(x - p.Position[0], 2) + pow(y - p.Position[1], 2))            sum_corner[1] += pow(p.Radius, 2) / (pow((x + cell_size_x) - p.Position[0], 2) + pow(y - p.Position[1], 2))            sum_corner[2] += pow(p.Radius, 2) / (                pow((x + cell_size_x) - p.Position[0], 2) + pow((y + cell_size_y) - p.Position[1], 2))            sum_corner[3] += pow(p.Radius, 2) / (pow(x - p.Position[0], 2) + pow((y + cell_size_y) - p.Position[1], 2))    for corner in sum_corner:        if corner > 1:            score += '1'        else:            score += '0'    if int(score, 2) != 0 or int(score, 2) != 15:        lines = DrawLine(score, x, y, cell_size_x, cell_size_y, sum_corner)        return lines    else:        return []def createRandCircle(min_radius, max_radius, sh, sw, max_dx, max_dy):    p = Particle()    p.SetRadius(random.randrange(min_radius, max_radius))    p.SetPosition([random.randrange(p.Radius, sw - p.Radius), p.Radius])  # random.randrange(p.Radius, sh - p.Radius)    p.SetMovement([random.random() * max_dx + 1, p.Radius + (random.random() * 3)])  #    return pif __name__ == '__main__':    pygame.init()    windowSurface = pygame.display.set_mode((500, 400), 0, 32)    pygame.display.set_caption("Paint")    # get screen size    info = pygame.display.Info()    sw = info.current_w    sh = info.current_h    grid = CalculateGrid(sw, sh, 30)  # 26    y_size = len(grid[:])    x_size = len(grid[0])    cell_size_x = sw / x_size    cell_size_y = sh / y_size    print x_size, y_size    print cell_size_x, cell_size_y    max_dx = 0    max_dy = 7    min_radius = 10    max_radius = 15    circle_objs = []    num_circles = 7    num_cores = multiprocessing.cpu_count()    print "num_cores", num_cores    for i in range(0, num_circles):        circle_objs += [createRandCircle(min_radius, max_radius, sh, sw, max_dx, max_dy)]    BLACK = (0, 0, 0)    GREEN = (0, 255, 0)    windowSurface.fill(BLACK)    while True:        for event in pygame.event.get():            if event.type == QUIT:                pygame.quit()                sys.exit()            if event.type == pygame.KEYDOWN:                if event.key == pygame.K_SPACE:                    circle_objs += [createRandCircle(min_radius, max_radius, sh, sw, max_dx, max_dy)]        windowSurface.fill(BLACK)        # Make parallel        for particle in circle_objs:            if (particle.Position[1] + particle.Radius) + 1 < sh:                particle.SetPosition([particle.Position[0] + 0, particle.Position[1] + particle.Movement[1]])            elif particle.Position[1] + 1 < sh:                dy = particle.Movement[1] - 0.5 if particle.Movement[1] > 0 else 0                dx = particle.Movement[0] - 0.5 if particle.Movement[1] > 0 else 0                particle.SetMovement([dx, dy])        for particle in circle_objs:            if particle.DecreaseLifetime():                circle_objs.remove(particle)            # update position with direction            # pos = particle.Position            # print dx, dy            # # check bounds            # if (pos[0] - radius) + dx < 0 or (pos[0] + radius) + dx > sw:            #     dx = -dx            #     particle.SetMovement([dx, dy])            # if (pos[1] - radius) + dy < 0 or (pos[1] + radius) + dy > sh:            #     dy = -dy            #     particle.SetMovement([dx, dy])        # Make parallel        lines = joblib.Parallel(n_jobs=1)(joblib.delayed(ComputeSquares)(i, grid, circle_objs, x_size, cell_size_x,                                                                         cell_size_y) for i in range(0, x_size * y_size))        # print lines        for line in lines:            if line != None and len(line) > 0:                pygame.draw.lines(windowSurface, GREEN, False, line, 1)        pygame.time.Clock().tick(20)        pygame.display.update()